/*
 * kaffe.def
 * Kaffe instruction definitions.
 *
 * Copyright (c) 1996, 1997
 *	Transvirtual Technologies, Inc.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution 
 * of this file. 
 */

define_insn(NOP)
{
        /*
         * No operation.
         */
}

define_insn(ACONST_NULL)
{
	/*
	 * ... -> ..., 0
	 */
	push(1);
	move_ref_const(stack(0), 0);
}

define_insn(ICONST_M1)
define_insn_alias(ICONST_0)
define_insn_alias(ICONST_1)
define_insn_alias(ICONST_2)
define_insn_alias(ICONST_3)
define_insn_alias(ICONST_4)
define_insn_alias(ICONST_5)
{
	/*
	 * ... -> ..., [-1 .. 5]
	 */
	push(1);
	move_int_const(stack(0), getopcode() - ICONST_0);
}

define_insn(LCONST_0)
define_insn_alias(LCONST_1)
{
	/*
	 * ... -> ..., 0, [0 .. 1]
	 */
	push(2);
	move_long_const(stack_long(0), getopcode() - LCONST_0);
}

define_insn(FCONST_0)
define_insn_alias(FCONST_1)
define_insn_alias(FCONST_2)
{
	/*
	 * ... -> ..., [0.0 .. 2.0]
	 */
	push(1);
	move_float_const(stack(0), (jfloat)(getopcode() - FCONST_0));
}

define_insn(DCONST_0)
define_insn_alias(DCONST_1)
{
	/*
	 * ... -> ..., [0.0 .. 1.0]
	 */
	push(2);
	move_double_const(stack_double(0), (jdouble)(getopcode() - DCONST_0));
}

define_insn(BIPUSH)
{
	/*
	 * ... -> ..., val
	 */
	check_pc (0);

	low = (int8)getpc(0);
	push(1);
	move_int_const(stack(0), low);
}

define_insn(SIPUSH)
{
	/*
	 * ... -> ..., val
	 */
	check_pcidx (0);

	low = (int16)((getpc(0) << 8) | getpc(1));
	push(1);
	move_int_const(stack(0), low);
}

define_insn(LDC1)
{
	/*
	 * ... -> ..., const
	 */
	check_pc (0);

	idx = (uint8)getpc(0);
	push(1);
	switch (CLASS_CONST_TAG(current_class(), idx)) {
	case CONSTANT_ResolvedString:
		move_string_const(stack(0), (void*)CLASS_CONST_DATA(current_class(),idx));
		break;
	case CONSTANT_Float:
		move_float_const(stack(0), *(float*)&CLASS_CONST_DATA(current_class(),idx));
		break;
	case CONSTANT_Integer:
		move_int_const(stack(0), CLASS_CONST_DATA(current_class(),idx));
		break;
	default:
		ABORT();
	}
}

define_insn(LDC2)
{
	/*
	 * ... -> ..., const
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));
	push(1);
	switch (CLASS_CONST_TAG(current_class(), idx)) {
	case CONSTANT_ResolvedString:
		move_string_const(stack(0), (void*)CLASS_CONST_DATA(current_class(),idx));
		break;
	case CONSTANT_Float:
		move_float_const(stack(0), *(jfloat*)&CLASS_CONST_DATA(current_class(),idx));
		break;
	case CONSTANT_Integer:
		move_int_const(stack(0), CLASS_CONST_DATA(current_class(),idx));
		break;
	default:
		ABORT();
	}
}

define_insn(LDC2W)
{
	/*
	 * ... -> ..., long const
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));
	tmpl = CLASS_CONST_LONG (current_class(), idx);
	push(2);
	switch (CLASS_CONST_TAG(current_class(), idx)) {
	case CONSTANT_Long:
		move_long_const(stack_long(0), tmpl);
		break;
	case CONSTANT_Double:
		move_double_const(stack_double(0), *(jdouble*)&tmpl);
		break;
	default:
		ABORT();
	}
}

define_insn(ILOAD)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_local_int(idx);

	push(1);
	move_int(stack(0), local(idx));
}

define_insn(LLOAD)
{
	/*
	 * ..., -> ..., long local variable
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_local_long(idx+1);

	push(2);
	move_long(stack_long(0), local_long(idx));
}

define_insn(FLOAD)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_local_float(idx);

	push(1);
	move_float(stack(0), local_float(idx));
}

define_insn(DLOAD)
{
	/*
	 * ..., -> ..., double local variable
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_local_double(idx+1);

	push(2);
	move_double(stack_double(0), local_double(idx));
}

define_insn(ALOAD)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_local_ref(idx);

	push(1);
	move_ref(stack(0), local(idx));
}

define_insn(ILOAD_0)
define_insn_alias(ILOAD_1)
define_insn_alias(ILOAD_2)
define_insn_alias(ILOAD_3)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_local_int(getopcode() - ILOAD_0);

	push(1);
	move_int(stack(0), local(getopcode() - ILOAD_0));
}

define_insn(LLOAD_0)
define_insn_alias(LLOAD_1)
define_insn_alias(LLOAD_2)
define_insn_alias(LLOAD_3)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_local_long((getopcode() - LLOAD_0)+1);

	push(2);
	move_long(stack_long(0), local_long(getopcode() - LLOAD_0));
}

define_insn(FLOAD_0)
define_insn_alias(FLOAD_1)
define_insn_alias(FLOAD_2)
define_insn_alias(FLOAD_3)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_local_float(getopcode() - FLOAD_0);

	push(1);
	move_float(stack(0), local_float(getopcode() - FLOAD_0));
}

define_insn(DLOAD_0)
define_insn_alias(DLOAD_1)
define_insn_alias(DLOAD_2)
define_insn_alias(DLOAD_3)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_local_double((getopcode() - DLOAD_0)+1);

	push(2);
	move_double(stack_double(0), local_double(getopcode() - DLOAD_0));
}

define_insn(ALOAD_0)
define_insn_alias(ALOAD_1)
define_insn_alias(ALOAD_2)
define_insn_alias(ALOAD_3)
{
	/*
	 * ..., -> ..., local variable
	 */
	check_local_ref(getopcode() - ALOAD_0);

	push(1);
	move_ref(stack(0), local(getopcode() - ALOAD_0));
}

define_insn(IALOAD)
{
	/*
	 * ..., array ref, index -> ..., value
	 */
	check_stack_int(0);
	check_stack_intarray(1);

	CHECK_NULL (IALOAD, rstack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_int(stack(1), rstack(1), rstack(0), object_array_offset);
	pop(1);
}

define_insn(LALOAD)
{
	/*
	 * ..., array ref, index -> ..., long value
	 */
	check_stack_int(0);
	check_stack_longarray(1);

	CHECK_NULL (LALOAD, stack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_long(stack_long(0), stack(1), stack(0), object_array_offset);
}

define_insn(FALOAD)
{
	/*
	 * ..., array ref, index -> ..., float value
	 */
	check_stack_int(0);
	check_stack_floatarray(1);

	CHECK_NULL (FALOAD, stack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_float(stack(1), stack(1), stack(0), object_array_offset);

	pop(1);
}

define_insn(DALOAD)
{
	/*
	 * ..., array ref, index -> ..., double value
	 */
	check_stack_int(0);
	check_stack_doublearray(1);

	CHECK_NULL (DALOAD, stack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_double(stack_double(0), stack(1), stack(0), object_array_offset);
}

define_insn(AALOAD)
{
	/*
	 * ..., array ref, index -> ..., ref value
	 */
	check_stack_int(0);
	check_stack_refarray(1);

	CHECK_NULL(AALOAD, rstack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_ref(stack(1), rstack(1), rstack(0), object_array_offset);
	pop(1);
}

define_insn(BALOAD)
{
	/*
	 * ..., array ref, index -> ..., byte value
	 */
	check_stack_int(0);
	check_stack_bytearray(1);

	CHECK_NULL(BALOAD, rstack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_byte(stack(1), rstack(1), rstack(0), object_array_offset);
	pop(1);
}

define_insn(CALOAD)
{
	/*
	 * ..., array ref, index -> ..., char value
	 */
	check_stack_int(0);
	check_stack_chararray(1);

	CHECK_NULL(CALOAD, rstack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_char(stack(1), rstack(1), rstack(0), object_array_offset);
	pop(1);
}

define_insn(SALOAD)
{
	/*
	 * ..., array ref, index -> ..., short value
	 */
	check_stack_int(0);
	check_stack_shortarray(1);

	CHECK_NULL(SALOAD, rstack(1), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(1), rstack(0));

	load_offset_scaled_short(stack(1), rstack(1), rstack(0), object_array_offset);
	pop(1);
}

define_insn(ISTORE)
{
	/*
	 * ..., var -> ...
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_stack_int(0);

	move_int(local(idx), stack(0));
	pop(1);
}

define_insn(LSTORE)
{
	/*
	 * ..., long var -> ...
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_stack_long(0);

	move_long(local_long(idx), stack_long(0));
	pop(2);
}

define_insn(FSTORE)
{
	/*
	 * ..., var -> ...
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_stack_float(0);

	move_float(local_float(idx), stack(0));
	pop(1);
}

define_insn(DSTORE)
{
	/*
	 * ..., var -> ...
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_stack_double(0);

	move_double(local_double(idx), stack_double(0));
	pop(2);
}

define_insn(ASTORE)
{
	/*
	 * ..., var -> ...
	 */
	check_pc (0);
	idx = (uint8)getpc(0);

	check_stack_ref(0);

	move_ref(local(idx), stack(0));
	pop(1);
}

define_insn(ISTORE_0)
define_insn_alias(ISTORE_1)
define_insn_alias(ISTORE_2)
define_insn_alias(ISTORE_3)
{
	/*
	 * ..., val -> ...
	 */
	check_stack_int(0);

	move_int(local(getopcode() - ISTORE_0), stack(0));
	pop(1);
}

define_insn(LSTORE_0)
define_insn_alias(LSTORE_1)
define_insn_alias(LSTORE_2)
define_insn_alias(LSTORE_3)
{
	/*
	 * ..., long val -> ...
	 */
	check_stack_long(0);

	move_long(local_long(getopcode() - LSTORE_0), stack_long(0));
	pop(2);
}

define_insn(FSTORE_0)
define_insn_alias(FSTORE_1)
define_insn_alias(FSTORE_2)
define_insn_alias(FSTORE_3)
{
	/*
	 * ..., val -> ...
	 */
	check_stack_float(0);

	move_float(local_float(getopcode() - FSTORE_0), stack(0));
	pop(1);
}

define_insn(DSTORE_0)
define_insn_alias(DSTORE_1)
define_insn_alias(DSTORE_2)
define_insn_alias(DSTORE_3)
{
	/*
	 * ..., double val -> ...
	 */
	check_stack_double(0);

	move_double(local_double(getopcode() - DSTORE_0), stack_double(0));
	pop(2);
}

define_insn(ASTORE_0)
define_insn_alias(ASTORE_1)
define_insn_alias(ASTORE_2)
define_insn_alias(ASTORE_3)
{
	/*
	 * ..., val -> ...
	 */
	check_stack_ref(0);

	move_ref(local(getopcode() - ASTORE_0), stack(0));
	pop(1);
}

define_insn(IASTORE)
{
	/*
	 * ..., array ref, index, val -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_intarray(2);

	CHECK_NULL(IASTORE, rstack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	store_offset_scaled_int(rstack(2), rstack(1), object_array_offset, rstack(0));
	pop(3);
}

define_insn(LASTORE)
{
	/*
	 * ..., array ref, index, long val -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_longarray(2);

	CHECK_NULL(LASTORE, stack(3), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(3), rstack(2));

	store_offset_scaled_long(stack(3), stack(2), object_array_offset, stack_long(0));
	pop(4);
}

define_insn(FASTORE)
{
	/*
	 * ..., array ref, index, float val -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_floatarray(2);

	CHECK_NULL(FASTORE, stack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	store_offset_scaled_float(stack(2), stack(1), object_array_offset, stack(0));
	pop(3);
}

define_insn(DASTORE)
{
	/*
	 * ..., array ref, index, double val -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_doublearray(2);

	CHECK_NULL(DASTORE, stack(3), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(3), rstack(2));

	store_offset_scaled_long(stack(3), stack(2), object_array_offset, stack_double(0));

	pop(4);
}

define_insn(AASTORE)
{
	/*
	 * ..., array ref, index, val -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_refarray(2);

	CHECK_NULL(AASTORE, rstack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	softcall_checkarraystore(rstack(2), rstack(0));

	SOFT_ADDREFERENCE(rstack(2), rstack(0));

	store_offset_scaled_ref(rstack(2), rstack(1), object_array_offset, rstack(0));
	pop(3);
}

define_insn(BASTORE)
{
	/*
	 * ..., array ref, index, byte value  -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_bytearray(2);

	CHECK_NULL(BASTORE, rstack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	store_offset_scaled_byte(rstack(2), rstack(1), object_array_offset, rstack(0));
	pop(3);
}

define_insn(CASTORE)
{
	/*
	 * ..., array ref, index, char value  -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_chararray(2);

	CHECK_NULL(CASTORE, rstack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	store_offset_scaled_char(rstack(2), rstack(1), object_array_offset, rstack(0));
	pop(3);
}

define_insn(SASTORE)
{
	/*
	 * ..., array ref, index, short value  -> ...
	 */
	check_stack_int(0);
	check_stack_int(1);
	check_stack_shortarray(2);

	CHECK_NULL(SASTORE, rstack(2), 34);

	/* Check we are within the array bounds */
	check_array_index(rstack(2), rstack(1));

	store_offset_scaled_short(rstack(2), rstack(1), object_array_offset, rstack(0));
	pop(3);
}

define_insn(POP)
{
	pop(1);
}

define_insn(POP2)
{
	pop(2);
}

define_insn(DUP)
{
	push(1);
	move_any(stack(0), stack(1));
}

define_insn(DUP_X1)
{
	push(1);
	move_any(stack(0), stack(1));
	move_any(stack(1), stack(2));
	move_any(stack(2), stack(0));
}

define_insn(DUP_X2)
{
	push(1);
	move_any(stack(0), stack(1));
	move_any(stack(1), stack(2));
	move_any(stack(2), stack(3));
	move_any(stack(3), stack(0));
}

define_insn(DUP2)
{
	push(2);
	move_any(stack(0), stack(2));
	move_any(stack(1), stack(3));
}

define_insn(DUP2_X1)
{
	push(2);
	move_any(stack(0), stack(2));
	move_any(stack(1), stack(3));
	move_any(stack(2), stack(4));
	move_any(stack(3), stack(0));
	move_any(stack(4), stack(1));
}

define_insn(DUP2_X2)
{
	push(2);
	move_any(stack(0), stack(2));
	move_any(stack(1), stack(3));
	move_any(stack(2), stack(4));
	move_any(stack(3), stack(5));
	move_any(stack(4), stack(0));
	move_any(stack(5), stack(1));
}

define_insn(SWAP)
{
        /*
         * ..., val1, val2 -> ..., val2, val1
         */
	swap_any(stack(0), stack(1));
}

define_insn(IADD)
{
        /*
         * ..., val1, val2 -> ..., val1+val2
         */
	check_stack_int(0);
	check_stack_int(1);

	add_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LADD)
{
        /*
         * ..., long val1, long val2 -> ..., long val1+val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	add_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(FADD)
{
        /*
         * ..., val1, val2 -> ..., val1+val2
         */
	check_stack_float(0);
	check_stack_float(1);

	add_float(stack_float(1), rstack_float(1), rstack_float(0));
	pop(1);
}

define_insn(DADD)
{
        /*
         * ..., double val1, long val2 -> ..., double val1+val2
         */
	check_stack_double(0);
	check_stack_double(2);

	add_double(stack_double(2), rstack_double(2), rstack_double(0));
	pop(2);
}

define_insn(ISUB)
{
        /*
         * ..., val1, val2 -> ..., val1-val2
         */
	check_stack_int(0);
	check_stack_int(1);

	sub_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LSUB)
{
        /*
         * ..., long val1, long val2 -> ..., long val1-val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	sub_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(FSUB)
{
        /*
         * ..., val1, val2 -> ..., val1-val2
         */
	check_stack_float(0);
	check_stack_float(1);

	sub_float(stack_float(1), rstack_float(1), rstack_float(0));
	pop(1);
}

define_insn(DSUB)
{
        /*
         * ..., double val1, long val2 -> ..., double val1-val2
         */
	check_stack_double(0);
	check_stack_double(2);

	sub_double(stack_double(2), rstack_double(2), rstack_double(0));
	pop(2);
}

define_insn(IMUL)
{
        /*
         * ..., val1, val2 -> ..., val1*val2
         */
	check_stack_int(0);
	check_stack_int(1);

	mul_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LMUL)
{
        /*
         * ..., long val1, long val2 -> ..., long val1*val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	mul_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(FMUL)
{
        /*
         * ..., val1, val2 -> ..., val1*val2
         */
	check_stack_float(0);
	check_stack_float(1);

	mul_float(stack_float(1), rstack_float(1), rstack_float(0));
	pop(1);
}

define_insn(DMUL)
{
        /*
         * ..., double val1, long val2 -> ..., double val1*val2
         */
	check_stack_double(0);
	check_stack_double(2);

	mul_double(stack_double(2), rstack_double(2), rstack_double(0));
	pop(2);
}

define_insn(IDIV)
{
        /*
         * ..., val1, val2 -> ..., val1/val2
         */
	check_stack_int(0);
	check_stack_int(1);

	div_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LDIV)
{
        /*
         * ..., long val1, long val2 -> ..., long val1/val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	div_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(FDIV)
{
        /*
         * ..., val1, val2 -> ..., val1/val2
         */
	check_stack_float(0);
	check_stack_float(1);

	div_float(stack_float(1), rstack_float(1), rstack_float(0));
	pop(1);
}

define_insn(DDIV)
{
        /*
         * ..., val1, val2 -> ..., val1/val2
         */
	check_stack_double(0);
	check_stack_double(2);

	div_double(stack_double(2), rstack_double(2), rstack_double(0));
	pop(2);
}

define_insn(IREM)
{
        /*
         * ..., val1, val2 -> ..., val1%val2
         */
	check_stack_int(0);
	check_stack_int(1);

	rem_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LREM)
{
        /*
         * ..., long val1, long val2 -> ..., long val1%val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	rem_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(FREM)
{
        /*
         * ..., val1, val2 -> ..., val1%val2
         */
	check_stack_float(0);
	check_stack_float(1);

	rem_float(stack_float(1), rstack_float(1), rstack_float(0));
	pop(1);
}

define_insn(DREM)
{
        /*
         * ..., val1, val2 -> ..., val1%val2
         */
	check_stack_double(0);
	check_stack_double(2);

	rem_double(stack_double(2), rstack_double(2), rstack_double(0));
	pop(2);
}

define_insn(INEG)
{
	check_stack_int(0);

	neg_int(stack(0), rstack(0));
}

define_insn(LNEG)
{
	check_stack_long(0);

	slot_nowriteback2(stack_long(0));

	neg_long(stack_long(0), rstack_long(0));
}

define_insn(FNEG)
{
	check_stack_float(0);

	neg_float(stack_float(0), rstack_float(0));
}

define_insn(DNEG)
{
	check_stack_double(0);

	neg_double(stack_double(0), rstack_double(0));
}

define_insn(ISHL)
{
	/*
	 * ..., val1, val2 -> ... val1 << val2
	 */
	check_stack_int(0);
	check_stack_int(1);

	lshl_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LSHL)
{
	/*
	 * ..., long val1, val2 -> ... long val1 << val2
	 */
	check_stack_int(0);
	check_stack_long(1);

	slot_nowriteback(stack(0));
	slot_nowriteback2(stack_long(1));

	lshl_long(stack_long(1), stack_long(1), stack(0));
	pop(1);
}

define_insn(ISHR)
{
	/*
	 * ..., val1, val2 -> ... val1 >> val2
	 */
	check_stack_int(0);
	check_stack_int(1);

	ashr_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LSHR)
{
	/*
	 * ..., long val1, val2 -> ... long val1 >> val2
	 */
	check_stack_int(0);
	check_stack_long(1);

	slot_nowriteback(stack(0));
	slot_nowriteback2(stack_long(1));

	ashr_long(stack_long(1), stack_long(1), stack(0));
	pop(1);
}

define_insn(IUSHR)
{
	/*
	 * ..., val1, val2 -> ... val1 >> val2
	 */
	check_stack_int(0);
	check_stack_int(1);

	lshr_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LUSHR)
{
	/*
	 * ..., long val1, val2 -> ... long val1 >> val2
	 */
	check_stack_int(0);
	check_stack_long(1);

	slot_nowriteback(stack(0));
	slot_nowriteback2(stack_long(1));

	lshr_long(stack_long(1), stack_long(1), stack(0));
	pop(1);
}

define_insn(IAND)
{
        /*
         * ..., val1, val2 -> ..., val1 & val2
         */
	check_stack_int(0);
	check_stack_int(1);

	and_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LAND)
{
        /*
         * ..., long val1, long val2 -> ..., long val1 & val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	and_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(IOR)
{
        /*
         * ..., val1, val2 -> ..., val1 | val2
         */
	check_stack_int(0);
	check_stack_int(1);

	or_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LOR)
{
        /*
         * ..., long val1, long val2 -> ..., long val1 | val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	or_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(IXOR)
{
        /*
         * ..., val1, val2 -> ..., val1 ^ val2
         */
	check_stack_int(0);
	check_stack_int(1);

	xor_int(stack(1), rstack(1), rstack(0));
	pop(1);
}

define_insn(LXOR)
{
        /*
         * ..., long val1, long val2 -> ..., long val1 ^ val2
         */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	xor_long(stack_long(2), rstack_long(2), rstack_long(0));
	pop(2);
}

define_insn(IINC)
{
	check_pc (0);
	check_pc (1);
	idx = (uint8)getpc(0);
	low = (int8)getpc(1);

	check_local_int(idx);

	add_int_const(local(idx), local(idx), low);
}

define_insn(I2L)
{
	check_stack_int(0);

	push(1);
	cvt_int_long(stack_long(0), stack(1));
}

define_insn(I2F)
{
	check_stack_int(0);

	cvt_int_float(stack(0), stack(0));
}

define_insn(I2D)
{
	check_stack_int(0);

	push(1);
	cvt_int_double(stack_double(0), stack(1));
}

define_insn(L2I)
{
	check_stack_long(0);

	cvt_long_int(stack(1), stack_long(0));
	pop(1);
}

define_insn(L2F)
{
	check_stack_long(0);

	cvt_long_float(stack(1), stack_long(0));
	pop(1);
}

define_insn(L2D)
{
	check_stack_long(0);

	cvt_long_double(stack_double(0), stack_long(0));
}

define_insn(F2I)
{
	check_stack_float(0);

	cvt_float_int(stack(0), stack(0));
}

define_insn(F2L)
{
	check_stack_float(0);

	push(1);
	cvt_float_long(stack_long(0), stack(1));
}

define_insn(F2D)
{
	check_stack_float(0);

	push(1);
	cvt_float_double(stack_double(0), stack(1));
}

define_insn(D2I)
{
	check_stack_double(0);

	cvt_double_int(stack(1), stack_double(0));
	pop(1);
}

define_insn(D2L)
{
	check_stack_double(0);

	cvt_double_long(stack_long(0), stack_double(0));
}

define_insn(D2F)
{
	check_stack_double(0);

	cvt_double_float(stack(1), stack_double(0));
	pop(1);
}

define_insn(INT2BYTE)
{
	check_stack_int(0);

	cvt_int_byte(stack(0), rstack(0));
}

define_insn(INT2CHAR)
{
	check_stack_int(0);

	cvt_int_char(stack(0), rstack(0));
}

define_insn(INT2SHORT)
{
	check_stack_int(0);

	cvt_int_short(stack(0), rstack(0));
}

define_insn(LCMP)
{
	/*
	 * ..., long val1, long val2 -> ..., result
	 */
	check_stack_long(0);
	check_stack_long(2);

	slot_nowriteback2(stack_long(0));
	slot_nowriteback2(stack_long(2));

	lcmp(stack(3), rstack_long(0), rstack_long(2));
	pop(3);
}

define_insn(FCMPL)
{
	/*
	 * ..., float val1, float val2 -> ..., result
	 */
	check_stack_float(0);
	check_stack_float(1);

	cmpl_float(stack(1), stack(1), stack(0));
	pop(1);
}

define_insn(FCMPG)
{
	/*
	 * ..., float val1, float val2 -> ..., result
	 */
	check_stack_float(0);
	check_stack_float(1);

	cmpg_float(stack(1), stack(1), stack(0));
	pop(1);
}

define_insn(DCMPL)
{
	/*
	 * ..., double val1, double val2 -> ..., result
	 */
	check_stack_double(0);
	check_stack_double(2);

	cmpl_double(stack(3), stack_double(2), stack_double(0));
	pop(3);
}

define_insn(DCMPG)
{
	/*
	 * ..., double val1, double val2 -> ..., result
	 */
	check_stack_double(0);
	check_stack_double(2);

	cmpg_double(stack(3), stack_double(2), stack_double(0));
	pop(3);
}

define_insn(IFEQ)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_eq(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFNE)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_ne(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFLT)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_lt(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFGE)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_ge(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFGT)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_gt(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFLE)
{
	check_pcidx (0);
	check_stack_int(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_int_const_le(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IF_ICMPEQ)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_eq(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ICMPNE)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_ne(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ICMPLT)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_lt(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ICMPGE)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_ge(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ICMPGT)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_gt(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ICMPLE)
{
	check_pcidx (0);
	check_stack_int(0);
	check_stack_int(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_le(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ACMPEQ)
{
	check_pcidx (0);
	check_stack_ref(0);
	check_stack_ref(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_int_eq(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(IF_ACMPNE)
{
	check_pcidx (0);
	check_stack_ref(0);
	check_stack_ref(1);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	slot_nowriteback(stack(1));
	end_sub_block();

	cbranch_ref_ne(rstack(1), rstack(0), reference_code_label(pc+idx));

	pop(2);
}

define_insn(GOTO)
{
	check_pcidx (0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	end_sub_block();
	branch_a(reference_code_label(pc+idx));
}

define_insn(JSR)
{
	/*
	 * ... -> ..., ret-addr
	 */
	check_pcidx (0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	push(1);
	move_label_const(stack(0), reference_code_label(npc));
	end_sub_block();
	branch_a(reference_code_label(pc+idx));
}

define_insn(RET)
{
	check_pc (0);

	idx = (uint8)getpc(0);

	check_local_ref(idx);

	end_sub_block();
	branch_indirect(stored_code_label(local(idx)));
}

define_insn(TABLESWITCH)
{
	/*
	 * ..., index -> ...
	 */
	check_stack_int(0);

	slot_alloctmp(tmp2);

	npc = (pc + 1 + 3) & -4;
	low = (int32)((getcode(npc+4) << 24) | (getcode(npc+5) << 16) |
				(getcode(npc+6) << 8) | getcode(npc+7));
	high = (int32)((getcode(npc+8) << 24) | (getcode(npc+9) << 16) |
				(getcode(npc+10) << 8) | getcode(npc+11));
	npc = npc + 12;

	end_sub_block();
	cbranch_int_const_lt(stack(0), low, reference_label(TABLESWITCH, 8));
	if (low != 0) {
		start_sub_block();
		sub_int_const(stack(0), stack(0), low);
		end_sub_block();
	}
	cbranch_int_const_le(stack(0), high-low, reference_label(TABLESWITCH, 7));

	start_sub_block();
	set_label(TABLESWITCH, 8);
	move_int_const(stack(0), -3); /* Position at default entry */
	end_sub_block();

	start_sub_block();
	set_label(TABLESWITCH, 7);
	lshl_int_const(stack(0), stack(0), switchtable_shift);
	move_label_const(tmp2, reference_table_label(9));
	add_ref(stack(0), tmp2, stack(0));
	load_code_ref(stack(0), stack(0));
	end_sub_block();
	branch_indirect(table_code_label(stack(0)));
	pop(1);

	adjustpc((4 - (pc % 4)) + 12 + (high - low + 1) * 4);
}

define_insn(LOOKUPSWITCH)
{
	/*
	 * ..., key -> ...
	 */
	check_stack_int(0);

	npc = (pc + 1 + 3) & -4;
	idx = (int32)((getcode(npc+4) << 24) | (getcode(npc+5) << 16) |
				(getcode(npc+6) << 8) | getcode(npc+7));

	slot_alloctmp(mtable);
	slot_alloctmp(tmp);
	slot_alloctmp(tmp2);

	move_label_const(tmp2, reference_table_label(7));
	move_ref(tmp, tmp2);
	add_ref_const(tmp, tmp, idx * switchpair_size);

	end_sub_block();
	set_label(LOOKUPSWITCH, 5);
	start_sub_block();
	load_key(mtable, tmp);
	end_sub_block();
	cbranch_int_eq(mtable, stack(0), reference_label(LOOKUPSWITCH, 6));

	start_sub_block();
	add_ref_const(tmp, tmp, -switchpair_size);
	end_sub_block();
	cbranch_ref_ne(tmp, tmp2, reference_label(LOOKUPSWITCH, 5));

	start_sub_block();
	add_ref_const(tmp, tmp, -switchpair_addr);
	end_sub_block();

	set_label(LOOKUPSWITCH, 6);
	start_sub_block();
	add_ref_const(tmp, tmp, switchpair_addr);
	load_code_ref(tmp, tmp);
	end_sub_block();
	branch_indirect(table_code_label(tmp));
	pop(1);

	adjustpc((4 - (pc % 4)) + (idx + 1) * 8);
}

define_insn(IRETURN)
{
	check_stack_int(0);

	monitor_exit();
	returnarg_int(rstack(0));
	end_function();
	ret();
}

define_insn(LRETURN)
{
	check_stack_long(0);

	monitor_exit();
	returnarg_long(rstack_long(0));
	end_function();
	ret();
}

define_insn(FRETURN)
{
	check_stack_float(0);

	monitor_exit();
	returnarg_float(rstack_float(0));
	end_function();
	ret();
}

define_insn(DRETURN)
{
	check_stack_double(0);

	monitor_exit();
	returnarg_double(rstack_double(0));
	end_function();
	ret();
}

define_insn(ARETURN)
{
	check_stack_ref(0);

	monitor_exit();
	returnarg_ref(rstack_ref(0));
	end_function();
	ret();
}

define_insn(RETURN)
{
	monitor_exit();
	end_function();
	ret();
}

/*
 * This macro initialises the static data associated with a class.
 */
#define	INIT_STATIC_CLASS(c)				\
	if (c != 0 && c->state != CSTATE_OK) {		\
		softcall_initialise_class(c);		\
	}

define_insn(GETSTATIC)
{
	/*
	 * ... -> ..., value
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_static_field_info(idx);
	INIT_STATIC_CLASS(field_class());

	/* Use the proper load to increase the chances of the translator
	   getting data in the right type of register.  */

	if (FIELD_ISREF(finfo.field)) {
		push(1);
		load_addr_ref(stack(0), FIELD_ADDRESS(finfo.field));
	}
	else switch (CLASS_PRIM_SIG(FIELD_TYPE(finfo.field))) {
	case 'I':
		push(1);
		load_addr_int(stack(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'S':
		push(1);
		load_addr_short(stack(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'B':
	case 'Z':
		push(1);
		load_addr_byte(stack(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'C':
		push(1);
		load_addr_char(stack(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'F':
		push(1);
		load_addr_float(stack(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'J':
		push(2);
		load_addr_long(stack_long(0), FIELD_ADDRESS(finfo.field));
		break;
	case 'D':
		push(2);
		load_addr_double(stack_double(0), FIELD_ADDRESS(finfo.field));
		break;
	default:
		ABORT();
	}
}

define_insn(PUTSTATIC)
{
	/*
	 * ..., value  -> ...
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_static_field_info(idx);
	INIT_STATIC_CLASS(field_class());

	if (FIELD_ISREF(finfo.field)) {
		SOFT_ADDREFERENCE_STATIC(field_statics(), stack(0));
		store_addr_ref(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
	}
	else switch (CLASS_PRIM_SIG(FIELD_TYPE(finfo.field))) {
	case 'I':
		store_addr_int(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
		break;
	case 'S':
		store_addr_short(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
		break;
	case 'B':
	case 'Z':
		store_addr_byte(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
		break;
	case 'C':
		store_addr_char(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
		break;
	case 'F':
		store_addr_float(FIELD_ADDRESS(finfo.field), stack(0));
		pop(1);
		break;
	case 'J':
		store_addr_long(FIELD_ADDRESS(finfo.field), stack_long(0));
		pop(2);
		break;
	case 'D':
		store_addr_double(FIELD_ADDRESS(finfo.field), stack_double(0));
		pop(2);
		break;
	default:
		ABORT();
	}
}

define_insn(GETFIELD)
{
	/*
	 * ..., obj-ref -> ..., value
	 */
	check_pcidx (0);
	check_stack_ref(0);

	CHECK_NULL(GETFIELD, stack(0), 34);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_field_info(idx);

	/* Use the proper load to increase the chances of the translator
	   getting data in the right type of register.  */

	if (FIELD_ISREF(finfo.field)) {
		load_offset_ref(stack(0), rstack(0), FIELD_OFFSET(finfo.field));
	}
	else switch (CLASS_PRIM_SIG(FIELD_TYPE(finfo.field))) {
	case 'I':
		load_offset_int(stack(0), rstack(0), FIELD_OFFSET(finfo.field));
		break;
	case 'S':
		load_offset_short(stack(0), rstack(0), FIELD_OFFSET(finfo.field));
		break;
	case 'B':
	case 'Z':
		load_offset_byte(stack(0), rstack(0), FIELD_OFFSET(finfo.field));
		break;
	case 'C':
		load_offset_char(stack(0), rstack(0), FIELD_OFFSET(finfo.field));
		break;
	case 'F':
		load_offset_float(stack(0), stack(0), FIELD_OFFSET(finfo.field));
		break;
	case 'J':
		load_offset_long(stack_long(-1), stack(0), FIELD_OFFSET(finfo.field));
		push(1);
		break;
	case 'D':
		load_offset_double(stack_double(-1), stack(0), FIELD_OFFSET(finfo.field));
		push(1);
		break;

	default:
		ABORT();
	}
}

define_insn(PUTFIELD)
{
	/*
	 * ..., obj-ref, value  -> ...
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_field_info(idx);

	/* Use the proper store to increase the chances of the translator
	   having the data in the right type of register already.  */

	if (FIELD_ISREF(finfo.field)) {
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, rstack(1), 35);
		SOFT_ADDREFERENCE(rstack(1), rstack(0));
		store_offset_ref(rstack(1), FIELD_OFFSET(finfo.field), rstack(0));
		pop(2);
	}
	else switch (CLASS_PRIM_SIG(FIELD_TYPE(finfo.field))) {
	case 'I':
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, stack(1), 36);
		store_offset_int(stack(1), FIELD_OFFSET(finfo.field), stack(0));
		pop(2);
		break;
	case 'S':
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, stack(1), 37);
		store_offset_short(stack(1), FIELD_OFFSET(finfo.field), stack(0));
		pop(2);
		break;
	case 'B':
	case 'Z':
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, stack(1), 40);
		store_offset_byte(stack(1), FIELD_OFFSET(finfo.field), stack(0));
		pop(2);
		break;
	case 'C':
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, stack(1), 41);
		store_offset_char(stack(1), FIELD_OFFSET(finfo.field), stack(0));
		pop(2);
		break;
	case 'F':
		check_stack_ref(1);
		CHECK_NULL(PUTFIELD, stack(1), 42);
		store_offset_float(stack(1), FIELD_OFFSET(finfo.field), stack(0));
		pop(2);
		break;
	case 'J':
		check_stack_ref(2);
		CHECK_NULL(PUTFIELD, stack(2), 38);
		store_offset_long(stack(2), FIELD_OFFSET(finfo.field), stack_long(0));
		pop(3);
		break;
	case 'D':
		check_stack_ref(2);
		CHECK_NULL(PUTFIELD, stack(2), 39);
		store_offset_double(stack(2), FIELD_OFFSET(finfo.field), stack_double(0));
		pop(3);
		break;
	default:
		ABORT();
	}
}

#define	METHOD_RETURN_VALUE()					\
do {								\
	/* Store the return type (if necessary) */		\
	switch (low) {						\
	case 'V':						\
		break;						\
	case 'L':						\
	case '[':						\
		push(1);					\
		return_ref(stack(0));				\
		break;						\
	case 'I':						\
	case 'Z':						\
	case 'S':						\
	case 'B':						\
	case 'C':						\
		push(1);					\
		return_int(stack(0));				\
		break;						\
	case 'F':						\
		push(1);					\
		return_float(stack(0));				\
		break;						\
	case 'J':						\
		push(2);					\
		return_long(stack_long(0));			\
		break;						\
	case 'D':						\
		push(2);					\
		return_double(stack_double(0));			\
		break;						\
	default:						\
		ABORT();					\
	}							\
} while (0)

define_insn(INVOKEVIRTUAL)
{
	/*
	 * ..., obj, ..args.., -> ...
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	slot_alloctmp(tmp);
	slot_alloctmp(mtable);

	get_method_info(idx);

	/* If method doesn't exists, call 'NoSuchMethodError' */
	if (method_method() == 0) {
		softcall_nosuchmethod(method_class(), method_name(), method_sig());
		low = method_returntype();
		pop(method_nargs() + 1);
		METHOD_RETURN_VALUE();
	}
	else {
		idx = method_nargs();

		CHECK_NULL(INVOKEVIRTUAL, stack(idx), 34);

		check_stack_ref(idx);

		/* Find dispatch table in object */
		load_offset_ref(mtable, stack(idx), method_dtable_offset);

		/* Check method table for cached entry */
		load_offset_ref(tmp, mtable,
			DTABLE_METHODOFFSET + method_idx() * DTABLE_METHODSIZE);

		/* Push arguments & object */
		build_call_frame(method_sig(), stack(idx), idx);
		idx++;

		slot_nowriteback(tmp);
		pop(idx);
		end_sub_block();

		/* Call it */
		low = method_returntype();
		call(tmp);

		/* Pop args */
		popargs();

		start_sub_block();
		METHOD_RETURN_VALUE();
	}
}

define_insn(INVOKESPECIAL)
{
	/*
	 * ..., obj, ..args.., -> ...
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	slot_alloctmp(mtable);

	get_special_method_info(idx);

	/* If method doesn't exists, call 'NoSuchMethodError' */
	if (method_method() == 0) {
		softcall_nosuchmethod(method_class(), method_name(), method_sig());
		low = method_returntype();
		pop(method_nargs() + 1);
		METHOD_RETURN_VALUE();
	}
	else {
		idx = method_nargs();

		CHECK_NULL(INVOKESPECIAL, stack(idx), 34);

		check_stack_ref(idx);

		/* Push arguments & object */
		build_call_frame(method_sig(), stack(idx), idx);
		idx++;

		pop(idx);
		end_sub_block();

		/* Call it */
		low = method_returntype();

		call_indirect_method(method_method());

		/* Pop args */
		popargs();

		start_sub_block();
		METHOD_RETURN_VALUE();
	}
}

define_insn(INVOKESTATIC)
{
	/*
	 * ..., ..args.., -> ...
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_method_info(idx);

	/* If method doesn't exists, call 'NoSuchMethodError' */
	if (method_method() == 0) {
		softcall_nosuchmethod(method_class(), method_name(), method_sig());
		low = method_returntype();
		pop(method_nargs());
		METHOD_RETURN_VALUE();
	}
	else {
		idx = method_nargs();

		/* Push arguments */
		build_call_frame(method_sig(), 0, idx);

		pop(idx);
		end_sub_block();

		/* Call it */
		low = method_returntype();

		call_indirect_method(method_method());

		/* Pop args */
		popargs();

		start_sub_block();
		METHOD_RETURN_VALUE();
	}
}

define_insn(INVOKEINTERFACE)
{
	/*
	 * ..., obj, ..args.., -> ...
	 */
	check_pcidx (0);
	check_pc (2);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	slot_alloctmp(tmp);

	get_method_info(idx);

	/* If method doesn't exists, call 'NoSuchMethodError' */
	if (method_method() == 0) {
		softcall_nosuchmethod(method_class(), method_name(), method_sig());
		low = method_returntype();
		pop((uint8)getpc(2));
		METHOD_RETURN_VALUE();
	}
	else {
		idx = (uint8)getpc(2) - 1;

		CHECK_NULL(INVOKEINTERFACE, stack(idx), 34);

		check_stack_ref(idx);

		softcall_lookupmethod(tmp, method_method(), stack(idx));

		/* Push arguments & object */
		build_call_frame(method_sig(), stack(idx), idx);
		idx++;

		slot_nowriteback(tmp);
		pop(idx);
		end_sub_block();

		/* Call it */
		low = method_returntype();
		call(tmp);

		/* Pop args */
		popargs();

		start_sub_block();
		METHOD_RETURN_VALUE();
	}
}

define_insn(NEW)
{
	/*
	 * ... ->  ..., object ref
	 */
	check_pcidx (0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_class_info(idx);
	push(1);
	softcall_new(stack(0), class_object());
}

define_insn(NEWARRAY)
{
	/*
	 * ... size ->  ..., object ref
	 */
	check_pc (0);
	check_stack_int(0);

	low = (uint8)getpc(0);
	softcall_newarray(stack(0), stack(0), low);
}

define_insn(ANEWARRAY)
{
	/*
	 * ... size ->  ..., object ref
	 */
	check_pcidx (0);
	check_stack_int(0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_class_info(idx);
	softcall_anewarray(stack(0), stack(0), class_object());
}

define_insn(ARRAYLENGTH)
{
	/*
	 * ..., obj -> ..., length
	 */
	CHECK_NULL(ARRAYLENGTH, rstack(0), 34);

	check_stack_array(0);

	load_offset_int(stack(0), rstack(0), object_array_length);
}

define_insn(ATHROW)
{
	/*
	 * ..., obj -> undefined
	 */
	CHECK_NULL(ATHROW, rstack(0), 34);

	check_stack_ref(0);

	softcall_athrow(rstack(0));
}

define_insn(CHECKCAST)
{
	/*
	 * ..., obj -> ..., obj
	 */
	check_pcidx (0);
	check_stack_ref(0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_class_info(idx);
	softcall_checkcast(stack(0), rstack(0), class_object());
}

define_insn(INSTANCEOF)
{
	/*
	 * ..., obj -> ..., result
	 */
	check_pcidx (0);
	check_stack_ref(0);

	idx = (uint16)((getpc(0) << 8) | getpc(1));

	get_class_info(idx);
	softcall_instanceof(stack(0), rstack(0), class_object());
}

define_insn(MONITORENTER)
{
	/*
	 * ... obj -> ...
	 */
	CHECK_NULL(MONITORENTER, rstack(0), 34);

	check_stack_ref(0);

	softcall_monitorenter(rstack(0));
	pop(1);
}

define_insn(MONITOREXIT)
{
	/*
	 * ... obj -> ...
	 */
	CHECK_NULL(MONITOREXIT, rstack(0), 34);

	check_stack_ref(0);

	softcall_monitorexit(rstack(0));
	pop(1);
}

define_insn(WIDE)
{
	/* Move PC to widened instruction */
	pc = npc;
	npc = pc + insnLen[getopcode()] + 1;

	switch(getopcode()) {
	default:
		ABORT();

	define_insn(ILOAD)
	{
		/*
		 * ..., -> ..., local variable
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_local_int(idx);
 
		push(1);
		move_int(stack(0), local(idx));
	}
	define_insn(FLOAD)
	{
		/*
		 * ..., -> ..., local variable
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_local_float(idx);
 
		push(1);
		move_float(stack(0), local_float(idx));
	}
	define_insn(ALOAD)
	{
		/*
		 * ..., -> ..., local variable
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));
                
		check_local_ref(idx);  
 
		push(1);
		move_ref(stack(0), local(idx));
	}
	define_insn(LLOAD)
	{
		/*      
		 * ..., -> ..., long local variable
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));
                
		check_local_long(idx+1);

		push(2);
		move_long(stack_long(0), local_long(idx));
	}
	define_insn(DLOAD)
	{
		/*      
		 * ..., -> ..., double local variable
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));
                
		check_local_double(idx+1);

		push(2);
		move_double(stack_double(0), local_double(idx));
	}
	define_insn(ISTORE)
	{
		/*      
		 * ..., var -> ...
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_stack_int(0);
         
		move_int(local(idx), stack(0));
		pop(1); 
	}
	define_insn(FSTORE)
	{
		/*      
		 * ..., var -> ...
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));
 
		check_stack_float(0);
         
		move_float(local_float(idx), stack(0));
		pop(1); 
	}
	define_insn(ASTORE)
	{
		/*
		 * ..., var -> ...
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_stack_ref(0);

		move_ref(local(idx), stack(0));
		pop(1);
	}
	define_insn(LSTORE)
	{
		/*      
		 * ..., long var -> ...
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_stack_long(0);
 
		move_long(local_long(idx), stack_long(0));
		pop(2);
	}
	define_insn(DSTORE)
	{
		/*      
		 * ..., var -> ...
		 */
		check_pcidx (0);
		idx = (uint16)((getpc(0) << 8) | getpc(1));

		check_stack_double(0);
 
		move_double(local_double(idx), stack_double(0));
		pop(2);
	}
	define_insn(IINC)
	{
		check_pcidx (0);
		check_pcidx (2);
		idx = (uint16)((getpc(0) << 8) | getpc(1));
		low = (int16)((getpc(2) << 8) | getpc(3));
 
		check_local_int(idx);

		add_int_const(local(idx), local(idx), low);

		npc += 1;	/* Extra one */
	}
	}
}

define_insn(MULTIANEWARRAY)
{
	/*
	 * ... size1, size2, ... sizen ->  ..., object ref
	 */
	check_pcidx (0);
	check_pc (2);

	idx = (uint16)((getpc(0) << 8) | getpc(1));
	low = (uint8)getpc(2);

	for (high = 0; high < low; high++) {
		check_stack_int(high);
	}

	get_class_info(idx);
	softcall_multianewarray(stack(low-1), low, stack(0), class_object());

	pop(low-1);
}

define_insn(IFNULL)
{
	check_pcidx (0);
	check_stack_ref(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_ref_const_eq(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(IFNONNULL)
{
	check_pcidx (0);
	check_stack_ref(0);

	idx = (int16)((getpc(0) << 8) | getpc(1));

	slot_nowriteback(stack(0));
	end_sub_block();

	cbranch_ref_const_ne(rstack(0), 0, reference_code_label(pc+idx));

	pop(1);
}

define_insn(GOTO_W)
{
	check_pcwidx (0);

	idx = (int32)((getpc(0) << 24) | (getpc(1) << 16) |
				(getpc(2) << 8) | getpc(3));

	end_sub_block();
	branch_a(reference_code_label(pc+idx));
}

define_insn(JSR_W)
{
	/*
	 * ... -> ..., ret-addr
	 */
	check_pcwidx (0);

	idx = (int32)((getpc(0) << 24) | (getpc(1) << 16) |
				(getpc(2) << 8) | getpc(3));

	push(1);
	move_label_const(stack(0), reference_code_label(npc));
	end_sub_block();
	branch_a(reference_code_label(pc+idx));
}

define_insn(BREAKPOINT)
{
	breakpoint();
}
